(in-package #:cl-user)
(defpackage apriori-tests
  (:use :cl :prove :cl-data-structures.aux-package))

(in-package #:apriori-tests)

(plan 31)

(let* ((data #((1 2) (1 4) (1 2 4) (3 4)
               (1 3) (1 3) (1 3 4) (1 3 2)))
       (index (cl-ds.counting:set-index data 1))
       (index2 (cl-ds.counting:set-index data 1))
       (single-sets (cl-ds.alg:to-vector (cl-ds.counting:all-sets index 0.0 1)))
       (vector (cl-ds.alg:to-vector (cl-ds.counting:all-sets index 0.1))))
  (is (sort (map 'vector #'cl-ds.counting:content single-sets)
            (lambda (a b) (< (first a) (first b))))
      #((1) (2) (3) (4))
      :test #'equalp)
  (is (cl-ds.counting:type-count index) 4)
  (is-error (cl-ds.counting:make-association-set
             (cl-ds.counting:find-set index 1 3)
             (cl-ds.counting:find-set index2 1 2))
            'cl-ds:operation-not-allowed)
  (is-error (cl-ds.counting:find-set index 1 1) 'cl-ds:operation-not-allowed)
  (let ((empty-set (cl-ds.counting:find-set index 1 2 3 4)))
    (is (cl-ds.counting:support empty-set) 0)
    (is (cl-ds.counting:type-count empty-set) 4))
  (let ((empty-set (cl-ds.counting:find-set index 0 1 2 3)))
    (is (cl-ds.counting:support empty-set) 0)
    (is (cl-ds.counting:type-count empty-set) 4))
  (is (cl-ds:size vector) 13)
  (is (length vector)
      (length (remove-duplicates vector
                                 :test 'equal
                                 :key #'cl-ds.counting:content)))
  (ok (every (compose (curry #'<= 1)
                      #'cl-ds.counting:support)
             vector))
  (let* ((result (cl-ds.counting:find-association index '(1 3) '(4)))
         (set1 (cl-ds.counting:find-set index 1 2))
         (set2 (cl-ds.counting:find-set index 3 2))
         (apriori-set (cl-ds.counting:make-association-set set1 set2)))
    (ok result)
    (ok set1)
    (ok set2)
    (let ((super-sets (cl-ds.alg:to-vector (cl-ds.counting:all-super-sets set1 0.0))))
      (map-into super-sets 'cl-ds.counting:content super-sets)
      (map-into super-sets (lambda (x) (sort x #'<)) super-sets)
      (is (length super-sets) 3)
      (setf super-sets (coerce super-sets 'list))
      (ok (member '(1 2) super-sets :test 'equal))
      (ok (member '(1 2 3) super-sets :test 'equal))
      (ok (member '(1 2 4) super-sets :test 'equal)))
    (is (cl-ds.counting:type-count set1) 2)
    (is (cl-ds.counting:type-count set2) 2)
    (is (cl-ds.counting:type-count apriori-set) 3)
    (is (cl-ds.counting:support apriori-set) 1)
    (is (sort (cl-ds.counting:content (cl-ds.counting:apriori-set apriori-set)) #'<) '(1 2) :test #'equal)
    (is (sort (cl-ds.counting:content (cl-ds.counting:aposteriori-set apriori-set)) #'<) '(3) :test #'equal)
    (is (cl-ds.counting:type-count result) 3)
    (is (cl-ds.counting:type-count index) 4)
    (is (sort (cl-ds.counting:content result) #'<) '(1 3 4) :test #'equal)
    (is (sort (cl-ds.counting:content (cl-ds.counting:apriori-set result)) #'<) '(1 3) :test #'equal)
    (is (sort (cl-ds.counting:content (cl-ds.counting:aposteriori-set result)) #'<) '(4) :test #'equal)
    (is (cl-ds.counting:support result) 1)
    (is (cl-ds.counting:association-frequency result) 0.25 :test #'=)))

(finalize)
